{"version":3,"file":"workbox-core.prod.js","sources":["packages/workbox-core/_version.mjs","packages/workbox-core/models/LogLevels.mjs","packages/workbox-core/models/messages/messageGenerator.mjs","packages/workbox-core/_private/WorkboxError.mjs","packages/workbox-core/_private/cacheNames.mjs","packages/workbox-core/_private/logger.mjs","packages/workbox-core/_default.mjs","packages/workbox-core/models/pluginEvents.mjs","packages/workbox-core/utils/pluginUtils.mjs","packages/workbox-core/_private/cacheWrapper.mjs","packages/workbox-core/_private/fetchWrapper.mjs","packages/workbox-core/_private/DBWrapper.mjs","packages/workbox-core/_private/assert.mjs","packages/workbox-core/_private/getFriendlyURL.mjs","packages/workbox-core/browser.mjs"],"sourcesContent":["try{self.workbox.v['workbox:core:3.0.0-alpha.3']=1;}catch(e){} // eslint-disable-line","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport '../_version.mjs';\n\n/**\n * The available log levels in Workbox: debug, log, warn, error and silent.\n *\n * @property {int} debug Prints all logs from Workbox. Useful for debugging.\n * @property {int} log Prints console log, warn, error and groups. Default for\n * debug builds.\n * @property {int} warn Prints console warn, error and groups. Default for\n * non-debug builds.\n * @property {int} error Print console error and groups.\n * @property {int} silent Force no logging from Workbox.\n *\n * @alias workbox.core.LOG_LEVELS\n */\n\nexport default {\n  debug: 0,\n  log: 1,\n  warn: 2,\n  error: 3,\n  silent: 4,\n};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport messages from './messages.mjs';\nimport '../../_version.mjs';\n\nconst fallback = (code, ...args) => {\n  let msg = code;\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n  return msg;\n};\n\nconst generatorFunction = (code, ...args) => {\n  const message = messages[code];\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n\n  return message(...args);\n};\n\nconst exportedValue = (process.env.NODE_ENV === 'production') ?\n  fallback : generatorFunction;\n\nexport default exportedValue;\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport messageGenerator from '../models/messages/messageGenerator.mjs';\nimport '../_version.mjs';\n\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    let message = messageGenerator(errorCode, details);\n\n    super(message);\n\n    this.name = errorCode;\n    this.details = details;\n  }\n}\n\nexport {WorkboxError};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport '../_version.mjs';\n\nconst _cacheNameDetails = {\n  prefix: 'workbox',\n  suffix: self.registration.scope,\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache',\n  runtime: 'runtime',\n};\n\nconst _createCacheName = (cacheName) => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\n    .filter((value) => value.length > 0)\n    .join('-');\n};\n\nconst exports = {\n  updateDetails: (details) => {\n    Object.keys(_cacheNameDetails).forEach((key) => {\n      if (typeof details[key] !== 'undefined') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getRuntimeName: (userCacheName) => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n};\n\nexport {exports as cacheNames};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport LOG_LEVELS from '../models/LogLevels.mjs';\nimport '../_version.mjs';\n\nconst GREY = `#7f8c8d`;\nconst GREEN = `#2ecc71`;\nconst YELLOW = `#f39c12`;\nconst RED = `#c0392b`;\nconst BLUE = `#3498db`;\n\nconst getDefaultLogLevel = () => (process.env.NODE_ENV === 'production') ?\n  LOG_LEVELS.warn : LOG_LEVELS.log;\n\nlet logLevel = getDefaultLogLevel();\nconst shouldPrint = (minLevel) => (logLevel <= minLevel);\nconst setLoggerLevel = (newLogLevel) => logLevel = newLogLevel;\nconst getLoggerLevel = () => logLevel;\n\n// We always want groups to be logged unless logLevel is silent.\nconst groupLevel = LOG_LEVELS.error;\n\nconst _print = function(keyName, logArgs, levelColor) {\n  const logLevel = keyName.indexOf('group') === 0 ?\n    groupLevel : LOG_LEVELS[keyName];\n  if (!shouldPrint(logLevel)) {\n    return;\n  }\n\n  if (!levelColor) {\n    console[keyName](...logArgs);\n    return;\n  }\n\n  const logPrefix = [\n    '%cworkbox',\n    `background: ${levelColor}; color: white; padding: 2px 0.5em; ` +\n      `border-radius: 0.5em;`,\n  ];\n  console[keyName](...logPrefix, ...logArgs);\n};\n\nconst groupEnd = () => {\n  if (shouldPrint(groupLevel)) {\n    console.groupEnd();\n  }\n};\n\nconst defaultExport = {\n  groupEnd,\n  unprefixed: {\n    groupEnd,\n  },\n};\n\nconst setupLogs = (keyName, color) => {\n  defaultExport[keyName] =\n    (...args) => _print(keyName, args, color);\n  defaultExport.unprefixed[keyName] =\n    (...args) => _print(keyName, args);\n};\n\nconst levelToColor = {\n  debug: GREY,\n  log: GREEN,\n  warn: YELLOW,\n  error: RED,\n  groupCollapsed: BLUE,\n};\nObject.keys(levelToColor).forEach(\n  (keyName) => setupLogs(keyName, levelToColor[keyName])\n);\n\nexport {getDefaultLogLevel};\nexport {setLoggerLevel};\nexport {getLoggerLevel};\nexport {defaultExport as logger};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport LOG_LEVELS from './models/LogLevels.mjs';\nimport {WorkboxError} from './_private/WorkboxError.mjs';\nimport {cacheNames} from './_private/cacheNames.mjs';\nimport {logger} from './_private/logger.mjs';\nimport {assert} from './_private/assert.mjs';\nimport {setLoggerLevel, getLoggerLevel} from './_private/logger.mjs';\nimport './_version.mjs';\n\n/**\n * This class is never exposed publicly. Inidividual methods are exposed\n * using jsdoc alias commands.\n *\n * @memberof workbox.core\n * @private\n */\nclass WorkboxCore {\n  /**\n   * You should not instantiate this object directly.\n   *\n   * @private\n   */\n  constructor() {\n    // Give our version strings something to hang off of.\n    try {\n      self.workbox.v = self.workbox.v || {};\n    } catch (err) {\n      // NOOP\n    }\n\n    // A WorkboxCore instance must be exported before we can use the logger.\n    // This is so it can get the current log level.\n    if (process.env.NODE_ENV !== 'production') {\n      const padding = '   ';\n      logger.groupCollapsed('Welcome to Workbox!');\n      logger.unprefixed.log(\n        `üìñ Read the guides and documentation\\n` +\n        `${padding}https://developers.google.com/web/tools/workbox/`\n      );\n      logger.unprefixed.log(\n        `‚ùì Use the [workbox] tag on StackOverflow to ask questions\\n` +\n        `${padding}https://stackoverflow.com/questions/ask?tags=workbox`\n      );\n      logger.unprefixed.log(\n        `üêõ Found a bug? Report it on GitHub\\n` +\n        `${padding}https://github.com/GoogleChrome/workbox/issues/new`\n      );\n      logger.groupEnd();\n    }\n  }\n\n  /**\n   * Get the current cache names used by Workbox.\n   *\n   * `cacheNames.precache` is used for precached assets,\n   * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\n   * store `analytics.js`,\n   * and `cacheNames.runtime` is used for everything else.\n   *\n   * @return {Object} An object with `precache` and `runtime` cache names.\n   *\n   * @alias workbox.core.cacheNames\n   */\n  get cacheNames() {\n    return {\n      googleAnalytics: cacheNames.getGoogleAnalyticsName(),\n      precache: cacheNames.getPrecacheName(),\n      runtime: cacheNames.getRuntimeName(),\n    };\n  }\n\n  /**\n   * You can alter the default cache names used by the Workbox modules by\n   * changing the cache name details.\n   *\n   * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n   *\n   * @param {Object} details\n   * @param {Object} details.prefix The string to add to the beginning of\n   * the precache and runtime cache names.\n   * @param {Object} details.suffix The string to add to the end of\n   * the precache and runtime cache names.\n   * @param {Object} details.precache The cache name to use for precache\n   * caching.\n   * @param {Object} details.runtime The cache name to use for runtime caching.\n   * @param {Object} details.googleAnalytics The cache name to use for\n   * `workbox-google-analytics` caching.\n   *\n   * @alias workbox.core.setCacheNameDetails\n   */\n  setCacheNameDetails(details) {\n    if (process.env.NODE_ENV !== 'production') {\n      Object.keys(details).forEach((key) => {\n        assert.isType(details[key], 'string', {\n          moduleName: 'workbox-core',\n          className: 'WorkboxCore',\n          funcName: 'setCacheNameDetails',\n          paramName: `details.${key}`,\n        });\n      });\n\n      if ('precache' in details && details.precache.length === 0) {\n        throw new WorkboxError('invalid-cache-name', {\n          cacheNameId: 'precache',\n          value: details.precache,\n        });\n      }\n\n      if ('runtime' in details && details.runtime.length === 0) {\n        throw new WorkboxError('invalid-cache-name', {\n          cacheNameId: 'runtime',\n          value: details.runtime,\n        });\n      }\n\n      if ('googleAnalytics' in details &&\n        details.googleAnalytics.length === 0) {\n        throw new WorkboxError('invalid-cache-name', {\n          cacheNameId: 'googleAnalytics',\n          value: details.googleAnalytics,\n        });\n      }\n    }\n\n    cacheNames.updateDetails(details);\n  }\n\n  /**\n   * Get the current log level.\n   *\n   * @return {number}.\n   *\n   * @alias workbox.core.logLevel\n   */\n  get logLevel() {\n    return getLoggerLevel();\n  }\n\n  /**\n   * Set the current log level passing in one of the values from\n   * [LOG_LEVELS]{@link module:workbox-core.LOG_LEVELS}.\n   *\n   * @param {number} newLevel The new log level to use.\n   *\n   * @alias workbox.core.setLogLevel\n   */\n  setLogLevel(newLevel) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(newLevel, 'number', {\n        moduleName: 'workbox-core',\n        className: 'WorkboxCore',\n        funcName: 'logLevel [setter]',\n        paramName: `logLevel`,\n      });\n    }\n\n    if (newLevel > LOG_LEVELS.silent ||\n      newLevel < LOG_LEVELS.debug) {\n      throw new WorkboxError('invalid-value', {\n        paramName: 'logLevel',\n        validValueDescription: `Please use a value from LOG_LEVELS, i.e ` +\n          `'logLevel = workbox.core.LOG_LEVELS.debug'.`,\n        value: newLevel,\n      });\n    }\n\n    setLoggerLevel(newLevel);\n  }\n}\n\nexport default new WorkboxCore();\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport '../_version.mjs';\n\nexport default {\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n  FETCH_DID_FAIL: 'fetchDidFail',\n  REQUEST_WILL_FETCH: 'requestWillFetch',\n};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport '../_version.mjs';\n\nexport default {\n  filter: (plugins, callbackname) => {\n    return plugins.filter((plugin) => callbackname in plugin);\n  },\n};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {logger} from './logger.mjs';\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\nimport pluginEvents from '../models/pluginEvents.mjs';\nimport pluginUtils from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n/**\n * Wrapper around cache.put().\n *\n * Will call `cacheDidUpdate` on plugins if the cache was updated.\n *\n * @param {string} cacheName\n * @param {Request} request\n * @param {Response} response\n * @param {Array<Object>} [plugins]\n *\n * @private\n * @memberof module:workbox-core\n */\nconst putWrapper = async (cacheName, request, response, plugins = []) => {\n  let responseToCache = await _isResponseSafeToCache(\n    request, response, plugins);\n\n  // TODO If response is not safe to cache - print info to log.\n\n  if (!responseToCache) {\n    return;\n  }\n\n  const cache = await caches.open(cacheName);\n\n  const updatePlugins = pluginUtils.filter(\n    plugins, pluginEvents.CACHE_DID_UPDATE);\n\n  let oldResponse = updatePlugins.length > 0 ?\n    await matchWrapper(cacheName, request) : null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\n      `${getFriendlyURL(request.url)}.`);\n  }\n\n  // Regardless of whether or not we'll end up invoking\n  // cacheDidUpdate, wait until the cache is updated.\n  await cache.put(request, responseToCache);\n\n  for (let plugin of updatePlugins) {\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n      cacheName,\n      request,\n      oldResponse,\n      newResponse: responseToCache,\n    });\n  }\n};\n\n/**\n * This is a wrapper around cache.match().\n *\n * @param {string} cacheName Name of the cache to match against.\n * @param {Request} request The Request that will be used to look up cache\n * entries.\n * @param {Object} matchOptions Options passed to cache.match().\n * @param {Array<Object>} [plugins] Array of plugins.\n * @return {Response} A cached response if available.\n *\n * @private\n * @memberof module:workbox-core\n */\nconst matchWrapper = async (cacheName, request, matchOptions, plugins = []) => {\n  const cache = await caches.open(cacheName);\n  let cachedResponse = await cache.match(request, matchOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    if (cachedResponse) {\n      logger.debug(`Found a cached response in '${cacheName}'.`);\n    } else {\n      logger.debug(`No cached response found in '${cacheName}'.`);\n    }\n  }\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\n        .call(plugin, {\n          cacheName,\n          request,\n          matchOptions,\n          cachedResponse,\n        });\n    }\n  }\n  return cachedResponse;\n};\n\n/**\n * This method will call cacheWillUpdate on the available plugins (or use\n * response.ok) to determine if the Response is safe and valid to cache.\n *\n * @param {Request} request\n * @param {Response} response\n * @param {Array<Object>} plugins\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst _isResponseSafeToCache = async (request, response, plugins) => {\n  let responseToCache = response;\n  let pluginsUsed = false;\n  for (let plugin of plugins) {\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n      pluginsUsed = true;\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\n        .call(plugin, {\n          request,\n          response: responseToCache,\n        });\n    }\n  }\n\n  if (!pluginsUsed) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!responseToCache.ok) {\n        if (responseToCache.status === 0) {\n          // TODO: Add a link to guide on third-party request handling\n          logger.warn(`The response for '${request.url}' is an opaque ` +\n            `response. The caching strategy that you're using will not ` +\n            `cache opaque responses by default.`);\n        } else {\n          logger.debug(`The response for '${request.url}' returned ` +\n          `a status code of '${response.status}' and won't be cached as a ` +\n          `result.`);\n        }\n      }\n    }\n    responseToCache = responseToCache.ok ? responseToCache : null;\n  }\n\n  return responseToCache;\n};\n\nconst exports = {\n  put: putWrapper,\n  match: matchWrapper,\n};\n\nexport {exports as cacheWrapper};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {WorkboxError} from './WorkboxError.mjs';\nimport {logger} from './logger.mjs';\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\nimport pluginEvents from '../models/pluginEvents.mjs';\nimport pluginUtils from '../utils/pluginUtils.mjs';\nimport '../_version.mjs';\n\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Request|string} request\n * @param {Object} fetchOptions\n * @param {Array<Object>} [plugins]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async (request, fetchOptions, plugins = []) => {\n  if (typeof request === 'string') {\n    request = new Request(request);\n  }\n\n  // TODO Move to assertion\n  // assert.isInstance({request}, Request);\n\n  const failedFetchPlugins = pluginUtils.filter(\n    plugins, pluginEvents.FETCH_DID_FAIL);\n\n  // If there is a fetchDidFail plugin, we need to save a clone of the\n  // original request before it's either modified by a requestWillFetch\n  // plugin or before the original request's body is consumed via fetch().\n  const originalRequest = failedFetchPlugins.length > 0 ?\n    request.clone() : null;\n\n  try {\n    for (let plugin of plugins) {\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n          request: request.clone(),\n        });\n\n        // TODO: Move to assertion\n        // isInstance({request}, Request);\n      }\n    }\n  } catch (err) {\n    throw new WorkboxError('plugin-error-request-will-fetch', {\n      thrownError: err,\n    });\n  }\n\n  // The request can be altered by plugins with `requestWillFetch` making\n  // the original request (Most likely from a `fetch` event) to be different\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n  const pluginFilteredRequest = request.clone();\n\n  // TODO Log when the plugin filtered URL is different from the input request\n\n  try {\n    const response = await fetch(request, fetchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Network request for `+\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\n      `status '${response.status}'.`);\n    }\n    return response;\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.error(`Network request for `+\n      `'${getFriendlyURL(request.url)}' threw an error.`, err);\n    }\n\n    for (let plugin of failedFetchPlugins) {\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n        originalRequest: originalRequest.clone(),\n        request: pluginFilteredRequest.clone(),\n      });\n    }\n\n    throw err;\n  }\n};\n\nconst exports = {\n  fetch: wrappedFetch,\n};\n\nexport {exports as fetchWrapper};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport '../_version.mjs';\n\n/**\n * A class that wraps common IndexedDB functionality in a promise-based API.\n * It exposes all the underlying power and functionality of IndexedDB, but\n * wraps the most commonly used features in a way that's much simpler to use.\n *\n * @private\n */\nclass DBWrapper {\n  /**\n   * @param {string} name\n   * @param {number} version\n   * @param {Object=} [callback]\n   * @param {function(this:DBWrapper, Event)} [callbacks.onupgradeneeded]\n   * @param {function(this:DBWrapper, Event)} [callbacks.onversionchange]\n   *     Defaults to DBWrapper.prototype._onversionchange when not specified.\n   */\n  constructor(name, version, {\n    onupgradeneeded,\n    onversionchange = this._onversionchange,\n  } = {}) {\n    this._name = name;\n    this._version = version;\n    this._onupgradeneeded = onupgradeneeded;\n    this._onversionchange = onversionchange;\n\n    // If this is null, it means the database isn't open.\n    this._db = null;\n  }\n\n  /**\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n   * callback, and added an onversionchange callback to the database.\n   *\n   * @return {IDBDatabase}\n   *\n   * @private\n   */\n  async open() {\n    if (this._db) return;\n\n    this._db = await new Promise((resolve, reject) => {\n      // This flag is flipped to true if the timeout callback runs prior\n      // to the request failing or succeeding. Note: we use a timeout instead\n      // of an onblocked handler since there are cases where onblocked will\n      // never never run. A timeout better handles all possible scenarios:\n      // https://github.com/w3c/IndexedDB/issues/223\n      let openRequestTimedOut = false;\n      setTimeout(() => {\n        openRequestTimedOut = true;\n        reject(new Error('The open request was blocked and timed out'));\n      }, this.OPEN_TIMEOUT);\n\n      const openRequest = indexedDB.open(this._name, this._version);\n      openRequest.onerror = (evt) => reject(openRequest.error);\n      openRequest.onupgradeneeded = (evt) => {\n        if (openRequestTimedOut) {\n          openRequest.transaction.abort();\n          evt.target.result.close();\n        } else if (this._onupgradeneeded) {\n          this._onupgradeneeded(evt);\n        }\n      };\n      openRequest.onsuccess = (evt) => {\n        const db = evt.target.result;\n        if (openRequestTimedOut) {\n          db.close();\n        } else {\n          db.onversionchange = this._onversionchange;\n          resolve(db);\n        }\n      };\n    });\n\n    return this;\n  }\n\n  /**\n   * Delegates to the native `get()` method for the object store.\n   *\n   * @param {string} storeName The name of the object store to put the value.\n   * @param {...*} args The values passed to the delegated method.\n   * @return {*} The key of the entry.\n   *\n   * @private\n   */\n  async get(storeName, ...args) {\n    return await this._call('get', storeName, 'readonly', ...args);\n  }\n\n  /**\n   * Delegates to the native `add()` method for the object store.\n   *\n   * @param {string} storeName The name of the object store to put the value.\n   * @param {...*} args The values passed to the delegated method.\n   * @return {*} The key of the entry.\n   *\n   * @private\n   */\n  async add(storeName, ...args) {\n    return await this._call('add', storeName, 'readwrite', ...args);\n  }\n\n  /**\n   * Delegates to the native `put()` method for the object store.\n   *\n   * @param {string} storeName The name of the object store to put the value.\n   * @param {...*} args The values passed to the delegated method.\n   * @return {*} The key of the entry.\n   *\n   * @private\n   */\n  async put(storeName, ...args) {\n    return await this._call('put', storeName, 'readwrite', ...args);\n  }\n\n  /**\n   * Delegates to the native `delete()` method for the object store.\n   *\n   * @param {string} storeName\n   * @param {...*} args The values passed to the delegated method.\n   *\n   * @private\n   */\n  async delete(storeName, ...args) {\n    await this._call('delete', storeName, 'readwrite', ...args);\n  }\n\n  /**\n   * Delegates to the native `getAll()` or polyfills it via the `find()`\n   * method in older browsers.\n   *\n   * @param {string} storeName\n   * @param {*} query\n   * @param {number} count\n   * @return {Array}\n   *\n   * @private\n   */\n  async getAll(storeName, query, count) {\n    if ('getAll' in IDBObjectStore.prototype) {\n      return await this._call('getAll', storeName, 'readonly', query, count);\n    } else {\n      return await this.getAllMatching(storeName, {query, count});\n    }\n  }\n\n  /**\n   * Supports flexible lookup in an object store by specifying an index,\n   * query, direction, and count. This method returns an array of objects\n   * with the signature .\n   *\n   * @param {string} storeName\n   * @param {Object} [opts]\n   * @param {IDBCursorDirection} [opts.direction]\n   * @param {*} [opts.query]\n   * @param {string} [opts.index] The index to use (if specified).\n   * @param {number} [opts.count] The max number of results to return.\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\n   *     returned objects is changed from an array of values to an array of\n   *     objects in the form {key, primaryKey, value}.\n   * @return {Array}\n   *\n   * @private\n   */\n  async getAllMatching(storeName, opts = {}) {\n    return await this.transaction([storeName], 'readonly', (stores, done) => {\n      const store = stores[storeName];\n      const target = opts.index ? store.index(opts.index) : store;\n      const results = [];\n\n      target.openCursor(opts.query, opts.direction).onsuccess = (evt) => {\n        const cursor = evt.target.result;\n        if (cursor) {\n          const {primaryKey, key, value} = cursor;\n          results.push(opts.includeKeys ? {primaryKey, key, value} : value);\n          if (opts.count && results.length >= opts.count) {\n            done(results);\n          } else {\n            cursor.continue();\n          }\n        } else {\n          done(results);\n        }\n      };\n    });\n  }\n\n  /**\n   * Accepts a list of stores, a transaction type, and a callback and\n   * performs a transaction. A promise is returned that resolves to whatever\n   * value the callback chooses. The callback holds all the transaction logic\n   * and is invoked with three arguments:\n   *   1. An object mapping object store names to IDBObjectStore values.\n   *   2. A `done` function, that's used to resolve the promise when\n   *      when the transaction is done.\n   *   3. An `abort` function that can be called to abort the transaction\n   *      at any time.\n   *\n   * @param {Array<string>} storeNames An array of object store names\n   *     involved in the transaction.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {function(Object, function(), function(*)):?IDBRequest} callback\n   * @return {*} The result of the transaction ran by the callback.\n   *\n   * @private\n   */\n  async transaction(storeNames, type, callback) {\n    await this.open();\n    const result = await new Promise((resolve, reject) => {\n      const txn = this._db.transaction(storeNames, type);\n      const done = (value) => resolve(value);\n      const abort = () => {\n        reject(new Error('The transaction was manually aborted'));\n        txn.abort();\n      };\n      txn.onerror = (evt) => reject(evt.target.error);\n      txn.onabort = (evt) => reject(evt.target.error);\n      txn.oncomplete = () => resolve();\n\n      const stores = {};\n      for (const storeName of storeNames) {\n        stores[storeName] = txn.objectStore(storeName);\n      }\n      callback(stores, done, abort);\n    });\n    return result;\n  }\n\n  /**\n   * Delegates async to a native IDBObjectStore method.\n   *\n   * @param {string} method The method name.\n   * @param {string} storeName The object store name.\n   * @param {string} type Can be `readonly` or `readwrite`.\n   * @param {...*} args The list of args to pass to the native method.\n   * @return {*} The result of the transaction.\n   *\n   * @private\n   */\n  async _call(method, storeName, type, ...args) {\n    await this.open();\n    const callback = (stores, done) => {\n      stores[storeName][method](...args).onsuccess = (evt) => {\n        done(evt.target.result);\n      };\n    };\n\n    return await this.transaction([storeName], type, callback);\n  }\n\n  /**\n   * The default onversionchange handler, which closes the database so other\n   * connections can open without being blocked.\n   *\n   * @param {Event} evt\n   *\n   * @private\n   */\n  _onversionchange(evt) {\n    this.close();\n  }\n\n  /**\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\n   * doesn't need to be called since:\n   *   1. It's usually better to keep a connection open since opening\n   *      a new connection is somewhat slow.\n   *   2. Connections are automatically closed when the reference is\n   *      garbage collected.\n   * The primary use case for needing to close a connection is when another\n   * reference (typically in another tab) needs to upgrade it and would be\n   * blocked by the current, open connection.\n   *\n   * @private\n   */\n  close() {\n    if (this._db) this._db.close();\n  }\n}\n\n// Exposed to let users modify the default timeout on a per-instance\n// or global basis.\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\n\nexport {DBWrapper};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {WorkboxError} from '../_private/WorkboxError.mjs';\nimport '../_version.mjs';\n\n/*\n * This method returns true if the current context is a service worker.\n */\nconst isSwEnv = (moduleName) => {\n  if (!('ServiceWorkerGlobalScope' in self)) {\n    throw new WorkboxError('not-in-sw', {moduleName});\n  }\n};\n\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\n  if (!Array.isArray(value)) {\n    throw new WorkboxError('not-an-array', {\n      moduleName,\n      className,\n      funcName,\n      paramName,\n    });\n  }\n};\n\nconst hasMethod = (object, expectedMethod,\n                   {moduleName, className, funcName, paramName}) => {\n  const type = typeof object[expectedMethod];\n  if (type !== 'function') {\n    throw new WorkboxError('missing-a-method', {paramName, expectedMethod,\n      moduleName, className, funcName});\n  }\n};\n\nconst isType = (object, expectedType,\n                {moduleName, className, funcName, paramName}) => {\n  if (typeof object !== expectedType) {\n    throw new WorkboxError('incorrect-type', {paramName, expectedType,\n      moduleName, className, funcName});\n  }\n};\n\nconst isInstance = (object, expectedClass,\n                    {moduleName, className, funcName, paramName}) => {\n  if (!(object instanceof expectedClass)) {\n    throw new WorkboxError('incorrect-class', {paramName, expectedClass,\n      moduleName, className, funcName});\n  }\n};\n\nconst isOneOf = (value, validValues, {paramName}) => {\n  if (!validValues.includes(value)) {\n    throw new WorkboxError('invalid-value', {\n      paramName,\n      value,\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\n    });\n  }\n};\n\nconst isArrayOfClass = (value, expectedClass,\n  {moduleName, className, funcName, paramName}) => {\n  const error = new WorkboxError('not-array-of-class', {\n    value, expectedClass,\n    moduleName, className, funcName, paramName,\n  });\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n\n  for (let item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\n\nconst finalExports = process.env.NODE_ENV === 'production' ? null : {\n  hasMethod,\n  isArray,\n  isInstance,\n  isOneOf,\n  isSwEnv,\n  isType,\n  isArrayOfClass,\n};\n\nexport {finalExports as assert};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport '../_version.mjs';\n\nconst getFriendlyURL = (url) => {\n  const urlObj = new URL(url, location);\n  if (urlObj.origin === location.origin) {\n    return urlObj.pathname;\n  }\n  return urlObj.href;\n};\n\nexport {getFriendlyURL};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport defaultExport from './_default.mjs';\nimport LOG_LEVELS from './models/LogLevels.mjs';\nimport * as _private from './_private.mjs';\nimport './_version.mjs';\n\nconst finalExports = Object.assign(defaultExport, {\n  LOG_LEVELS,\n  _private,\n});\n\nexport default finalExports;\n"],"names":["workbox","v","e","exportedValue","code","args","msg","length","JSON","stringify","WorkboxError","Error","errorCode","details","messageGenerator","name","_cacheNameDetails","self","registration","scope","_createCacheName","cacheName","prefix","suffix","filter","value","join","exports","keys","forEach","key","userCacheName","googleAnalytics","precache","runtime","logLevel","process","warn","shouldPrint","minLevel","groupLevel","LOG_LEVELS","error","_print","keyName","logArgs","levelColor","indexOf","logPrefix","groupEnd","defaultExport","levelToColor","Object","color","unprefixed","setupLogs","WorkboxCore","err","cacheNames","getGoogleAnalyticsName","getPrecacheName","getRuntimeName","updateDetails","newLevel","silent","debug","newLogLevel","plugins","callbackname","plugin","putWrapper","request","response","responseToCache","_isResponseSafeToCache","cache","caches","open","updatePlugins","pluginUtils","pluginEvents","CACHE_DID_UPDATE","oldResponse","matchWrapper","put","call","matchOptions","cachedResponse","match","CACHED_RESPONSE_WILL_BE_USED","pluginsUsed","CACHE_WILL_UPDATE","ok","fetchOptions","Request","failedFetchPlugins","FETCH_DID_FAIL","originalRequest","clone","REQUEST_WILL_FETCH","pluginFilteredRequest","fetch","DBWrapper","version","onupgradeneeded","onversionchange","this","_onversionchange","_name","_version","_onupgradeneeded","_db","_this","Promise","resolve","reject","openRequestTimedOut","OPEN_TIMEOUT","openRequest","indexedDB","onerror","evt","transaction","abort","target","result","close","onsuccess","db","storeName","_this2","_call","_this3","_this4","_this5","query","count","IDBObjectStore","prototype","_this6","getAllMatching","opts","_this7","stores","done","store","results","index","openCursor","direction","cursor","primaryKey","push","includeKeys","continue","storeNames","type","callback","_this8","txn","onabort","oncomplete","objectStore","method","_this9","url","urlObj","URL","location","origin","pathname","href","assign"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9ob21lL21hdHQvUHJvamVjdHMvQ29kZS93b3JrYm94L2dlbmVyYXRlZC1yZWxlYXNlLWZpbGVzL3YzLjAuMC1hbHBoYS4zL3NvdXJjZS1jb2RlL3BhY2thZ2VzL3dvcmtib3gtY29yZS9fdmVyc2lvbi5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LWNvcmUvbW9kZWxzL0xvZ0xldmVscy5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LWNvcmUvbW9kZWxzL21lc3NhZ2VzL21lc3NhZ2VHZW5lcmF0b3IubWpzIiwiL2hvbWUvbWF0dC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjMvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvY2FjaGVOYW1lcy5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLm1qcyIsIi9ob21lL21hdHQvUHJvamVjdHMvQ29kZS93b3JrYm94L2dlbmVyYXRlZC1yZWxlYXNlLWZpbGVzL3YzLjAuMC1hbHBoYS4zL3NvdXJjZS1jb2RlL3BhY2thZ2VzL3dvcmtib3gtY29yZS9fZGVmYXVsdC5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LWNvcmUvbW9kZWxzL3BsdWdpbkV2ZW50cy5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LWNvcmUvdXRpbHMvcGx1Z2luVXRpbHMubWpzIiwiL2hvbWUvbWF0dC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjMvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlV3JhcHBlci5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZmV0Y2hXcmFwcGVyLm1qcyIsIi9ob21lL21hdHQvUHJvamVjdHMvQ29kZS93b3JrYm94L2dlbmVyYXRlZC1yZWxlYXNlLWZpbGVzL3YzLjAuMC1hbHBoYS4zL3NvdXJjZS1jb2RlL3BhY2thZ2VzL3dvcmtib3gtY29yZS9fcHJpdmF0ZS9EQldyYXBwZXIubWpzIiwiL2hvbWUvbWF0dC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjMvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LWNvcmUvX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwubWpzIiwiL2hvbWUvbWF0dC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjMvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1jb3JlL2Jyb3dzZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInRyeXtzZWxmLndvcmtib3gudlsnd29ya2JveDpjb3JlOjMuMC4wLWFscGhhLjMnXT0xO31jYXRjaChlKXt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUiLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogVGhlIGF2YWlsYWJsZSBsb2cgbGV2ZWxzIGluIFdvcmtib3g6IGRlYnVnLCBsb2csIHdhcm4sIGVycm9yIGFuZCBzaWxlbnQuXG4gKlxuICogQHByb3BlcnR5IHtpbnR9IGRlYnVnIFByaW50cyBhbGwgbG9ncyBmcm9tIFdvcmtib3guIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICogQHByb3BlcnR5IHtpbnR9IGxvZyBQcmludHMgY29uc29sZSBsb2csIHdhcm4sIGVycm9yIGFuZCBncm91cHMuIERlZmF1bHQgZm9yXG4gKiBkZWJ1ZyBidWlsZHMuXG4gKiBAcHJvcGVydHkge2ludH0gd2FybiBQcmludHMgY29uc29sZSB3YXJuLCBlcnJvciBhbmQgZ3JvdXBzLiBEZWZhdWx0IGZvclxuICogbm9uLWRlYnVnIGJ1aWxkcy5cbiAqIEBwcm9wZXJ0eSB7aW50fSBlcnJvciBQcmludCBjb25zb2xlIGVycm9yIGFuZCBncm91cHMuXG4gKiBAcHJvcGVydHkge2ludH0gc2lsZW50IEZvcmNlIG5vIGxvZ2dpbmcgZnJvbSBXb3JrYm94LlxuICpcbiAqIEBhbGlhcyB3b3JrYm94LmNvcmUuTE9HX0xFVkVMU1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGVidWc6IDAsXG4gIGxvZzogMSxcbiAgd2FybjogMixcbiAgZXJyb3I6IDMsXG4gIHNpbGVudDogNCxcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgbWVzc2FnZXMgZnJvbSAnLi9tZXNzYWdlcy5tanMnO1xuaW1wb3J0ICcuLi8uLi9fdmVyc2lvbi5tanMnO1xuXG5jb25zdCBmYWxsYmFjayA9IChjb2RlLCAuLi5hcmdzKSA9PiB7XG4gIGxldCBtc2cgPSBjb2RlO1xuICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgbXNnICs9IGAgOjogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gO1xuICB9XG4gIHJldHVybiBtc2c7XG59O1xuXG5jb25zdCBnZW5lcmF0b3JGdW5jdGlvbiA9IChjb2RlLCAuLi5hcmdzKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcbiAgaWYgKCFtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBtZXNzYWdlIGZvciBjb2RlICcke2NvZGV9Jy5gKTtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlKC4uLmFyZ3MpO1xufTtcblxuY29uc3QgZXhwb3J0ZWRWYWx1ZSA9IChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSA/XG4gIGZhbGxiYWNrIDogZ2VuZXJhdG9yRnVuY3Rpb247XG5cbmV4cG9ydCBkZWZhdWx0IGV4cG9ydGVkVmFsdWU7XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgbWVzc2FnZUdlbmVyYXRvciBmcm9tICcuLi9tb2RlbHMvbWVzc2FnZXMvbWVzc2FnZUdlbmVyYXRvci5tanMnO1xuaW1wb3J0ICcuLi9fdmVyc2lvbi5tanMnO1xuXG4vKipcbiAqIFdvcmtib3ggZXJyb3JzIHNob3VsZCBiZSB0aHJvd24gd2l0aCB0aGlzIGNsYXNzLlxuICogVGhpcyBhbGxvd3MgdXNlIHRvIGVuc3VyZSB0aGUgdHlwZSBlYXNpbHkgaW4gdGVzdHMsXG4gKiBoZWxwcyBkZXZlbG9wZXJzIGlkZW50aWZ5IGVycm9ycyBmcm9tIHdvcmtib3hcbiAqIGVhc2lseSBhbmQgYWxsb3dzIHVzZSB0byBvcHRpbWlzZSBlcnJvclxuICogbWVzc2FnZXMgY29ycmVjdGx5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFdvcmtib3hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvckNvZGUgVGhlIGVycm9yIGNvZGUgdGhhdFxuICAgKiBpZGVudGlmaWVzIHRoaXMgcGFydGljdWxhciBlcnJvci5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBkZXRhaWxzIEFueSByZWxldmFudCBhcmd1bWVudHNcbiAgICogdGhhdCB3aWxsIGhlbHAgZGV2ZWxvcGVycyBpZGVudGlmeSBpc3N1ZXMgc2hvdWxkXG4gICAqIGJlIGFkZGVkIGFzIGEga2V5IG9uIHRoZSBjb250ZXh0IG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVycm9yQ29kZSwgZGV0YWlscykge1xuICAgIGxldCBtZXNzYWdlID0gbWVzc2FnZUdlbmVyYXRvcihlcnJvckNvZGUsIGRldGFpbHMpO1xuXG4gICAgc3VwZXIobWVzc2FnZSk7XG5cbiAgICB0aGlzLm5hbWUgPSBlcnJvckNvZGU7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuXG5leHBvcnQge1dvcmtib3hFcnJvcn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbmNvbnN0IF9jYWNoZU5hbWVEZXRhaWxzID0ge1xuICBwcmVmaXg6ICd3b3JrYm94JyxcbiAgc3VmZml4OiBzZWxmLnJlZ2lzdHJhdGlvbi5zY29wZSxcbiAgZ29vZ2xlQW5hbHl0aWNzOiAnZ29vZ2xlQW5hbHl0aWNzJyxcbiAgcHJlY2FjaGU6ICdwcmVjYWNoZScsXG4gIHJ1bnRpbWU6ICdydW50aW1lJyxcbn07XG5cbmNvbnN0IF9jcmVhdGVDYWNoZU5hbWUgPSAoY2FjaGVOYW1lKSA9PiB7XG4gIHJldHVybiBbX2NhY2hlTmFtZURldGFpbHMucHJlZml4LCBjYWNoZU5hbWUsIF9jYWNoZU5hbWVEZXRhaWxzLnN1ZmZpeF1cbiAgICAuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUubGVuZ3RoID4gMClcbiAgICAuam9pbignLScpO1xufTtcblxuY29uc3QgZXhwb3J0cyA9IHtcbiAgdXBkYXRlRGV0YWlsczogKGRldGFpbHMpID0+IHtcbiAgICBPYmplY3Qua2V5cyhfY2FjaGVOYW1lRGV0YWlscykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRldGFpbHNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX2NhY2hlTmFtZURldGFpbHNba2V5XSA9IGRldGFpbHNba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgZ2V0R29vZ2xlQW5hbHl0aWNzTmFtZTogKHVzZXJDYWNoZU5hbWUpID0+IHtcbiAgICByZXR1cm4gdXNlckNhY2hlTmFtZSB8fCBfY3JlYXRlQ2FjaGVOYW1lKF9jYWNoZU5hbWVEZXRhaWxzLmdvb2dsZUFuYWx5dGljcyk7XG4gIH0sXG4gIGdldFByZWNhY2hlTmFtZTogKHVzZXJDYWNoZU5hbWUpID0+IHtcbiAgICByZXR1cm4gdXNlckNhY2hlTmFtZSB8fCBfY3JlYXRlQ2FjaGVOYW1lKF9jYWNoZU5hbWVEZXRhaWxzLnByZWNhY2hlKTtcbiAgfSxcbiAgZ2V0UnVudGltZU5hbWU6ICh1c2VyQ2FjaGVOYW1lKSA9PiB7XG4gICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5ydW50aW1lKTtcbiAgfSxcbn07XG5cbmV4cG9ydCB7ZXhwb3J0cyBhcyBjYWNoZU5hbWVzfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBMT0dfTEVWRUxTIGZyb20gJy4uL21vZGVscy9Mb2dMZXZlbHMubWpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24ubWpzJztcblxuY29uc3QgR1JFWSA9IGAjN2Y4YzhkYDtcbmNvbnN0IEdSRUVOID0gYCMyZWNjNzFgO1xuY29uc3QgWUVMTE9XID0gYCNmMzljMTJgO1xuY29uc3QgUkVEID0gYCNjMDM5MmJgO1xuY29uc3QgQkxVRSA9IGAjMzQ5OGRiYDtcblxuY29uc3QgZ2V0RGVmYXVsdExvZ0xldmVsID0gKCkgPT4gKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpID9cbiAgTE9HX0xFVkVMUy53YXJuIDogTE9HX0xFVkVMUy5sb2c7XG5cbmxldCBsb2dMZXZlbCA9IGdldERlZmF1bHRMb2dMZXZlbCgpO1xuY29uc3Qgc2hvdWxkUHJpbnQgPSAobWluTGV2ZWwpID0+IChsb2dMZXZlbCA8PSBtaW5MZXZlbCk7XG5jb25zdCBzZXRMb2dnZXJMZXZlbCA9IChuZXdMb2dMZXZlbCkgPT4gbG9nTGV2ZWwgPSBuZXdMb2dMZXZlbDtcbmNvbnN0IGdldExvZ2dlckxldmVsID0gKCkgPT4gbG9nTGV2ZWw7XG5cbi8vIFdlIGFsd2F5cyB3YW50IGdyb3VwcyB0byBiZSBsb2dnZWQgdW5sZXNzIGxvZ0xldmVsIGlzIHNpbGVudC5cbmNvbnN0IGdyb3VwTGV2ZWwgPSBMT0dfTEVWRUxTLmVycm9yO1xuXG5jb25zdCBfcHJpbnQgPSBmdW5jdGlvbihrZXlOYW1lLCBsb2dBcmdzLCBsZXZlbENvbG9yKSB7XG4gIGNvbnN0IGxvZ0xldmVsID0ga2V5TmFtZS5pbmRleE9mKCdncm91cCcpID09PSAwID9cbiAgICBncm91cExldmVsIDogTE9HX0xFVkVMU1trZXlOYW1lXTtcbiAgaWYgKCFzaG91bGRQcmludChsb2dMZXZlbCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWxldmVsQ29sb3IpIHtcbiAgICBjb25zb2xlW2tleU5hbWVdKC4uLmxvZ0FyZ3MpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGxvZ1ByZWZpeCA9IFtcbiAgICAnJWN3b3JrYm94JyxcbiAgICBgYmFja2dyb3VuZDogJHtsZXZlbENvbG9yfTsgY29sb3I6IHdoaXRlOyBwYWRkaW5nOiAycHggMC41ZW07IGAgK1xuICAgICAgYGJvcmRlci1yYWRpdXM6IDAuNWVtO2AsXG4gIF07XG4gIGNvbnNvbGVba2V5TmFtZV0oLi4ubG9nUHJlZml4LCAuLi5sb2dBcmdzKTtcbn07XG5cbmNvbnN0IGdyb3VwRW5kID0gKCkgPT4ge1xuICBpZiAoc2hvdWxkUHJpbnQoZ3JvdXBMZXZlbCkpIHtcbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbn07XG5cbmNvbnN0IGRlZmF1bHRFeHBvcnQgPSB7XG4gIGdyb3VwRW5kLFxuICB1bnByZWZpeGVkOiB7XG4gICAgZ3JvdXBFbmQsXG4gIH0sXG59O1xuXG5jb25zdCBzZXR1cExvZ3MgPSAoa2V5TmFtZSwgY29sb3IpID0+IHtcbiAgZGVmYXVsdEV4cG9ydFtrZXlOYW1lXSA9XG4gICAgKC4uLmFyZ3MpID0+IF9wcmludChrZXlOYW1lLCBhcmdzLCBjb2xvcik7XG4gIGRlZmF1bHRFeHBvcnQudW5wcmVmaXhlZFtrZXlOYW1lXSA9XG4gICAgKC4uLmFyZ3MpID0+IF9wcmludChrZXlOYW1lLCBhcmdzKTtcbn07XG5cbmNvbnN0IGxldmVsVG9Db2xvciA9IHtcbiAgZGVidWc6IEdSRVksXG4gIGxvZzogR1JFRU4sXG4gIHdhcm46IFlFTExPVyxcbiAgZXJyb3I6IFJFRCxcbiAgZ3JvdXBDb2xsYXBzZWQ6IEJMVUUsXG59O1xuT2JqZWN0LmtleXMobGV2ZWxUb0NvbG9yKS5mb3JFYWNoKFxuICAoa2V5TmFtZSkgPT4gc2V0dXBMb2dzKGtleU5hbWUsIGxldmVsVG9Db2xvcltrZXlOYW1lXSlcbik7XG5cbmV4cG9ydCB7Z2V0RGVmYXVsdExvZ0xldmVsfTtcbmV4cG9ydCB7c2V0TG9nZ2VyTGV2ZWx9O1xuZXhwb3J0IHtnZXRMb2dnZXJMZXZlbH07XG5leHBvcnQge2RlZmF1bHRFeHBvcnQgYXMgbG9nZ2VyfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBMT0dfTEVWRUxTIGZyb20gJy4vbW9kZWxzL0xvZ0xldmVscy5tanMnO1xuaW1wb3J0IHtXb3JrYm94RXJyb3J9IGZyb20gJy4vX3ByaXZhdGUvV29ya2JveEVycm9yLm1qcyc7XG5pbXBvcnQge2NhY2hlTmFtZXN9IGZyb20gJy4vX3ByaXZhdGUvY2FjaGVOYW1lcy5tanMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJy4vX3ByaXZhdGUvbG9nZ2VyLm1qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9fcHJpdmF0ZS9hc3NlcnQubWpzJztcbmltcG9ydCB7c2V0TG9nZ2VyTGV2ZWwsIGdldExvZ2dlckxldmVsfSBmcm9tICcuL19wcml2YXRlL2xvZ2dlci5tanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBpcyBuZXZlciBleHBvc2VkIHB1YmxpY2x5LiBJbmlkaXZpZHVhbCBtZXRob2RzIGFyZSBleHBvc2VkXG4gKiB1c2luZyBqc2RvYyBhbGlhcyBjb21tYW5kcy5cbiAqXG4gKiBAbWVtYmVyb2Ygd29ya2JveC5jb3JlXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBXb3JrYm94Q29yZSB7XG4gIC8qKlxuICAgKiBZb3Ugc2hvdWxkIG5vdCBpbnN0YW50aWF0ZSB0aGlzIG9iamVjdCBkaXJlY3RseS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEdpdmUgb3VyIHZlcnNpb24gc3RyaW5ncyBzb21ldGhpbmcgdG8gaGFuZyBvZmYgb2YuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGYud29ya2JveC52ID0gc2VsZi53b3JrYm94LnYgfHwge307XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBOT09QXG4gICAgfVxuXG4gICAgLy8gQSBXb3JrYm94Q29yZSBpbnN0YW5jZSBtdXN0IGJlIGV4cG9ydGVkIGJlZm9yZSB3ZSBjYW4gdXNlIHRoZSBsb2dnZXIuXG4gICAgLy8gVGhpcyBpcyBzbyBpdCBjYW4gZ2V0IHRoZSBjdXJyZW50IGxvZyBsZXZlbC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3QgcGFkZGluZyA9ICcgICAnO1xuICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKCdXZWxjb21lIHRvIFdvcmtib3ghJyk7XG4gICAgICBsb2dnZXIudW5wcmVmaXhlZC5sb2coXG4gICAgICAgIGDwn5OWIFJlYWQgdGhlIGd1aWRlcyBhbmQgZG9jdW1lbnRhdGlvblxcbmAgK1xuICAgICAgICBgJHtwYWRkaW5nfWh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi90b29scy93b3JrYm94L2BcbiAgICAgICk7XG4gICAgICBsb2dnZXIudW5wcmVmaXhlZC5sb2coXG4gICAgICAgIGDinZMgVXNlIHRoZSBbd29ya2JveF0gdGFnIG9uIFN0YWNrT3ZlcmZsb3cgdG8gYXNrIHF1ZXN0aW9uc1xcbmAgK1xuICAgICAgICBgJHtwYWRkaW5nfWh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zL2Fzaz90YWdzPXdvcmtib3hgXG4gICAgICApO1xuICAgICAgbG9nZ2VyLnVucHJlZml4ZWQubG9nKFxuICAgICAgICBg8J+QmyBGb3VuZCBhIGJ1Zz8gUmVwb3J0IGl0IG9uIEdpdEh1YlxcbmAgK1xuICAgICAgICBgJHtwYWRkaW5nfWh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvbmV3YFxuICAgICAgKTtcbiAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgY2FjaGUgbmFtZXMgdXNlZCBieSBXb3JrYm94LlxuICAgKlxuICAgKiBgY2FjaGVOYW1lcy5wcmVjYWNoZWAgaXMgdXNlZCBmb3IgcHJlY2FjaGVkIGFzc2V0cyxcbiAgICogYGNhY2hlTmFtZXMuZ29vZ2xlQW5hbHl0aWNzYCBpcyB1c2VkIGJ5IGB3b3JrYm94LWdvb2dsZS1hbmFseXRpY3NgIHRvXG4gICAqIHN0b3JlIGBhbmFseXRpY3MuanNgLFxuICAgKiBhbmQgYGNhY2hlTmFtZXMucnVudGltZWAgaXMgdXNlZCBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGBwcmVjYWNoZWAgYW5kIGBydW50aW1lYCBjYWNoZSBuYW1lcy5cbiAgICpcbiAgICogQGFsaWFzIHdvcmtib3guY29yZS5jYWNoZU5hbWVzXG4gICAqL1xuICBnZXQgY2FjaGVOYW1lcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ29vZ2xlQW5hbHl0aWNzOiBjYWNoZU5hbWVzLmdldEdvb2dsZUFuYWx5dGljc05hbWUoKSxcbiAgICAgIHByZWNhY2hlOiBjYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZSgpLFxuICAgICAgcnVudGltZTogY2FjaGVOYW1lcy5nZXRSdW50aW1lTmFtZSgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogWW91IGNhbiBhbHRlciB0aGUgZGVmYXVsdCBjYWNoZSBuYW1lcyB1c2VkIGJ5IHRoZSBXb3JrYm94IG1vZHVsZXMgYnlcbiAgICogY2hhbmdpbmcgdGhlIGNhY2hlIG5hbWUgZGV0YWlscy5cbiAgICpcbiAgICogQ2FjaGUgbmFtZXMgYXJlIGdlbmVyYXRlZCBhcyBgPHByZWZpeD4tPENhY2hlIE5hbWU+LTxzdWZmaXg+YC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRldGFpbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRldGFpbHMucHJlZml4IFRoZSBzdHJpbmcgdG8gYWRkIHRvIHRoZSBiZWdpbm5pbmcgb2ZcbiAgICogdGhlIHByZWNhY2hlIGFuZCBydW50aW1lIGNhY2hlIG5hbWVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGV0YWlscy5zdWZmaXggVGhlIHN0cmluZyB0byBhZGQgdG8gdGhlIGVuZCBvZlxuICAgKiB0aGUgcHJlY2FjaGUgYW5kIHJ1bnRpbWUgY2FjaGUgbmFtZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXRhaWxzLnByZWNhY2hlIFRoZSBjYWNoZSBuYW1lIHRvIHVzZSBmb3IgcHJlY2FjaGVcbiAgICogY2FjaGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRldGFpbHMucnVudGltZSBUaGUgY2FjaGUgbmFtZSB0byB1c2UgZm9yIHJ1bnRpbWUgY2FjaGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRldGFpbHMuZ29vZ2xlQW5hbHl0aWNzIFRoZSBjYWNoZSBuYW1lIHRvIHVzZSBmb3JcbiAgICogYHdvcmtib3gtZ29vZ2xlLWFuYWx5dGljc2AgY2FjaGluZy5cbiAgICpcbiAgICogQGFsaWFzIHdvcmtib3guY29yZS5zZXRDYWNoZU5hbWVEZXRhaWxzXG4gICAqL1xuICBzZXRDYWNoZU5hbWVEZXRhaWxzKGRldGFpbHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgT2JqZWN0LmtleXMoZGV0YWlscykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGFzc2VydC5pc1R5cGUoZGV0YWlsc1trZXldLCAnc3RyaW5nJywge1xuICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWNvcmUnLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ1dvcmtib3hDb3JlJyxcbiAgICAgICAgICBmdW5jTmFtZTogJ3NldENhY2hlTmFtZURldGFpbHMnLFxuICAgICAgICAgIHBhcmFtTmFtZTogYGRldGFpbHMuJHtrZXl9YCxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCdwcmVjYWNoZScgaW4gZGV0YWlscyAmJiBkZXRhaWxzLnByZWNhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbnZhbGlkLWNhY2hlLW5hbWUnLCB7XG4gICAgICAgICAgY2FjaGVOYW1lSWQ6ICdwcmVjYWNoZScsXG4gICAgICAgICAgdmFsdWU6IGRldGFpbHMucHJlY2FjaGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3J1bnRpbWUnIGluIGRldGFpbHMgJiYgZGV0YWlscy5ydW50aW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbnZhbGlkLWNhY2hlLW5hbWUnLCB7XG4gICAgICAgICAgY2FjaGVOYW1lSWQ6ICdydW50aW1lJyxcbiAgICAgICAgICB2YWx1ZTogZGV0YWlscy5ydW50aW1lLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdnb29nbGVBbmFseXRpY3MnIGluIGRldGFpbHMgJiZcbiAgICAgICAgZGV0YWlscy5nb29nbGVBbmFseXRpY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2ludmFsaWQtY2FjaGUtbmFtZScsIHtcbiAgICAgICAgICBjYWNoZU5hbWVJZDogJ2dvb2dsZUFuYWx5dGljcycsXG4gICAgICAgICAgdmFsdWU6IGRldGFpbHMuZ29vZ2xlQW5hbHl0aWNzLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWNoZU5hbWVzLnVwZGF0ZURldGFpbHMoZGV0YWlscyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGxvZyBsZXZlbC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfS5cbiAgICpcbiAgICogQGFsaWFzIHdvcmtib3guY29yZS5sb2dMZXZlbFxuICAgKi9cbiAgZ2V0IGxvZ0xldmVsKCkge1xuICAgIHJldHVybiBnZXRMb2dnZXJMZXZlbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCBsb2cgbGV2ZWwgcGFzc2luZyBpbiBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tXG4gICAqIFtMT0dfTEVWRUxTXXtAbGluayBtb2R1bGU6d29ya2JveC1jb3JlLkxPR19MRVZFTFN9LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbmV3TGV2ZWwgVGhlIG5ldyBsb2cgbGV2ZWwgdG8gdXNlLlxuICAgKlxuICAgKiBAYWxpYXMgd29ya2JveC5jb3JlLnNldExvZ0xldmVsXG4gICAqL1xuICBzZXRMb2dMZXZlbChuZXdMZXZlbCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQuaXNUeXBlKG5ld0xldmVsLCAnbnVtYmVyJywge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1jb3JlJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnV29ya2JveENvcmUnLFxuICAgICAgICBmdW5jTmFtZTogJ2xvZ0xldmVsIFtzZXR0ZXJdJyxcbiAgICAgICAgcGFyYW1OYW1lOiBgbG9nTGV2ZWxgLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5ld0xldmVsID4gTE9HX0xFVkVMUy5zaWxlbnQgfHxcbiAgICAgIG5ld0xldmVsIDwgTE9HX0xFVkVMUy5kZWJ1Zykge1xuICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignaW52YWxpZC12YWx1ZScsIHtcbiAgICAgICAgcGFyYW1OYW1lOiAnbG9nTGV2ZWwnLFxuICAgICAgICB2YWxpZFZhbHVlRGVzY3JpcHRpb246IGBQbGVhc2UgdXNlIGEgdmFsdWUgZnJvbSBMT0dfTEVWRUxTLCBpLmUgYCArXG4gICAgICAgICAgYCdsb2dMZXZlbCA9IHdvcmtib3guY29yZS5MT0dfTEVWRUxTLmRlYnVnJy5gLFxuICAgICAgICB2YWx1ZTogbmV3TGV2ZWwsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZXRMb2dnZXJMZXZlbChuZXdMZXZlbCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFdvcmtib3hDb3JlKCk7XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQ0FDSEVfRElEX1VQREFURTogJ2NhY2hlRGlkVXBkYXRlJyxcbiAgQ0FDSEVfV0lMTF9VUERBVEU6ICdjYWNoZVdpbGxVcGRhdGUnLFxuICBDQUNIRURfUkVTUE9OU0VfV0lMTF9CRV9VU0VEOiAnY2FjaGVkUmVzcG9uc2VXaWxsQmVVc2VkJyxcbiAgRkVUQ0hfRElEX0ZBSUw6ICdmZXRjaERpZEZhaWwnLFxuICBSRVFVRVNUX1dJTExfRkVUQ0g6ICdyZXF1ZXN0V2lsbEZldGNoJyxcbn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZmlsdGVyOiAocGx1Z2lucywgY2FsbGJhY2tuYW1lKSA9PiB7XG4gICAgcmV0dXJuIHBsdWdpbnMuZmlsdGVyKChwbHVnaW4pID0+IGNhbGxiYWNrbmFtZSBpbiBwbHVnaW4pO1xuICB9LFxufTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuL2xvZ2dlci5tanMnO1xuaW1wb3J0IHtnZXRGcmllbmRseVVSTH0gZnJvbSAnLi4vX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwubWpzJztcbmltcG9ydCBwbHVnaW5FdmVudHMgZnJvbSAnLi4vbW9kZWxzL3BsdWdpbkV2ZW50cy5tanMnO1xuaW1wb3J0IHBsdWdpblV0aWxzIGZyb20gJy4uL3V0aWxzL3BsdWdpblV0aWxzLm1qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgY2FjaGUucHV0KCkuXG4gKlxuICogV2lsbCBjYWxsIGBjYWNoZURpZFVwZGF0ZWAgb24gcGx1Z2lucyBpZiB0aGUgY2FjaGUgd2FzIHVwZGF0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBbcGx1Z2luc11cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LWNvcmVcbiAqL1xuY29uc3QgcHV0V3JhcHBlciA9IGFzeW5jIChjYWNoZU5hbWUsIHJlcXVlc3QsIHJlc3BvbnNlLCBwbHVnaW5zID0gW10pID0+IHtcbiAgbGV0IHJlc3BvbnNlVG9DYWNoZSA9IGF3YWl0IF9pc1Jlc3BvbnNlU2FmZVRvQ2FjaGUoXG4gICAgcmVxdWVzdCwgcmVzcG9uc2UsIHBsdWdpbnMpO1xuXG4gIC8vIFRPRE8gSWYgcmVzcG9uc2UgaXMgbm90IHNhZmUgdG8gY2FjaGUgLSBwcmludCBpbmZvIHRvIGxvZy5cblxuICBpZiAoIXJlc3BvbnNlVG9DYWNoZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oY2FjaGVOYW1lKTtcblxuICBjb25zdCB1cGRhdGVQbHVnaW5zID0gcGx1Z2luVXRpbHMuZmlsdGVyKFxuICAgIHBsdWdpbnMsIHBsdWdpbkV2ZW50cy5DQUNIRV9ESURfVVBEQVRFKTtcblxuICBsZXQgb2xkUmVzcG9uc2UgPSB1cGRhdGVQbHVnaW5zLmxlbmd0aCA+IDAgP1xuICAgIGF3YWl0IG1hdGNoV3JhcHBlcihjYWNoZU5hbWUsIHJlcXVlc3QpIDogbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlci5kZWJ1ZyhgVXBkYXRpbmcgdGhlICcke2NhY2hlTmFtZX0nIGNhY2hlIHdpdGggYSBuZXcgUmVzcG9uc2UgZm9yIGAgK1xuICAgICAgYCR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfS5gKTtcbiAgfVxuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3Qgd2UnbGwgZW5kIHVwIGludm9raW5nXG4gIC8vIGNhY2hlRGlkVXBkYXRlLCB3YWl0IHVudGlsIHRoZSBjYWNoZSBpcyB1cGRhdGVkLlxuICBhd2FpdCBjYWNoZS5wdXQocmVxdWVzdCwgcmVzcG9uc2VUb0NhY2hlKTtcblxuICBmb3IgKGxldCBwbHVnaW4gb2YgdXBkYXRlUGx1Z2lucykge1xuICAgIGF3YWl0IHBsdWdpbltwbHVnaW5FdmVudHMuQ0FDSEVfRElEX1VQREFURV0uY2FsbChwbHVnaW4sIHtcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHJlcXVlc3QsXG4gICAgICBvbGRSZXNwb25zZSxcbiAgICAgIG5ld1Jlc3BvbnNlOiByZXNwb25zZVRvQ2FjaGUsXG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIHdyYXBwZXIgYXJvdW5kIGNhY2hlLm1hdGNoKCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSBOYW1lIG9mIHRoZSBjYWNoZSB0byBtYXRjaCBhZ2FpbnN0LlxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0IFRoZSBSZXF1ZXN0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGxvb2sgdXAgY2FjaGVcbiAqIGVudHJpZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hPcHRpb25zIE9wdGlvbnMgcGFzc2VkIHRvIGNhY2hlLm1hdGNoKCkuXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwbHVnaW5zXSBBcnJheSBvZiBwbHVnaW5zLlxuICogQHJldHVybiB7UmVzcG9uc2V9IEEgY2FjaGVkIHJlc3BvbnNlIGlmIGF2YWlsYWJsZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LWNvcmVcbiAqL1xuY29uc3QgbWF0Y2hXcmFwcGVyID0gYXN5bmMgKGNhY2hlTmFtZSwgcmVxdWVzdCwgbWF0Y2hPcHRpb25zLCBwbHVnaW5zID0gW10pID0+IHtcbiAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihjYWNoZU5hbWUpO1xuICBsZXQgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5tYXRjaChyZXF1ZXN0LCBtYXRjaE9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiAnJHtjYWNoZU5hbWV9Jy5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBObyBjYWNoZWQgcmVzcG9uc2UgZm91bmQgaW4gJyR7Y2FjaGVOYW1lfScuYCk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgaWYgKHBsdWdpbkV2ZW50cy5DQUNIRURfUkVTUE9OU0VfV0lMTF9CRV9VU0VEIGluIHBsdWdpbikge1xuICAgICAgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBwbHVnaW5bcGx1Z2luRXZlbnRzLkNBQ0hFRF9SRVNQT05TRV9XSUxMX0JFX1VTRURdXG4gICAgICAgIC5jYWxsKHBsdWdpbiwge1xuICAgICAgICAgIGNhY2hlTmFtZSxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoT3B0aW9ucyxcbiAgICAgICAgICBjYWNoZWRSZXNwb25zZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYWNoZWRSZXNwb25zZTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgd2lsbCBjYWxsIGNhY2hlV2lsbFVwZGF0ZSBvbiB0aGUgYXZhaWxhYmxlIHBsdWdpbnMgKG9yIHVzZVxuICogcmVzcG9uc2Uub2spIHRvIGRldGVybWluZSBpZiB0aGUgUmVzcG9uc2UgaXMgc2FmZSBhbmQgdmFsaWQgdG8gY2FjaGUuXG4gKlxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwbHVnaW5zXG4gKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIG1vZHVsZTp3b3JrYm94LWNvcmVcbiAqL1xuY29uc3QgX2lzUmVzcG9uc2VTYWZlVG9DYWNoZSA9IGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgcGx1Z2lucykgPT4ge1xuICBsZXQgcmVzcG9uc2VUb0NhY2hlID0gcmVzcG9uc2U7XG4gIGxldCBwbHVnaW5zVXNlZCA9IGZhbHNlO1xuICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGlmIChwbHVnaW5FdmVudHMuQ0FDSEVfV0lMTF9VUERBVEUgaW4gcGx1Z2luKSB7XG4gICAgICBwbHVnaW5zVXNlZCA9IHRydWU7XG4gICAgICByZXNwb25zZVRvQ2FjaGUgPSBhd2FpdCBwbHVnaW5bcGx1Z2luRXZlbnRzLkNBQ0hFX1dJTExfVVBEQVRFXVxuICAgICAgICAuY2FsbChwbHVnaW4sIHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZVRvQ2FjaGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcGx1Z2luc1VzZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFyZXNwb25zZVRvQ2FjaGUub2spIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAvLyBUT0RPOiBBZGQgYSBsaW5rIHRvIGd1aWRlIG9uIHRoaXJkLXBhcnR5IHJlcXVlc3QgaGFuZGxpbmdcbiAgICAgICAgICBsb2dnZXIud2FybihgVGhlIHJlc3BvbnNlIGZvciAnJHtyZXF1ZXN0LnVybH0nIGlzIGFuIG9wYXF1ZSBgICtcbiAgICAgICAgICAgIGByZXNwb25zZS4gVGhlIGNhY2hpbmcgc3RyYXRlZ3kgdGhhdCB5b3UncmUgdXNpbmcgd2lsbCBub3QgYCArXG4gICAgICAgICAgICBgY2FjaGUgb3BhcXVlIHJlc3BvbnNlcyBieSBkZWZhdWx0LmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIHJlc3BvbnNlIGZvciAnJHtyZXF1ZXN0LnVybH0nIHJldHVybmVkIGAgK1xuICAgICAgICAgIGBhIHN0YXR1cyBjb2RlIG9mICcke3Jlc3BvbnNlLnN0YXR1c30nIGFuZCB3b24ndCBiZSBjYWNoZWQgYXMgYSBgICtcbiAgICAgICAgICBgcmVzdWx0LmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3BvbnNlVG9DYWNoZSA9IHJlc3BvbnNlVG9DYWNoZS5vayA/IHJlc3BvbnNlVG9DYWNoZSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2VUb0NhY2hlO1xufTtcblxuY29uc3QgZXhwb3J0cyA9IHtcbiAgcHV0OiBwdXRXcmFwcGVyLFxuICBtYXRjaDogbWF0Y2hXcmFwcGVyLFxufTtcblxuZXhwb3J0IHtleHBvcnRzIGFzIGNhY2hlV3JhcHBlcn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQge1dvcmtib3hFcnJvcn0gZnJvbSAnLi9Xb3JrYm94RXJyb3IubWpzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICcuL2xvZ2dlci5tanMnO1xuaW1wb3J0IHtnZXRGcmllbmRseVVSTH0gZnJvbSAnLi4vX3ByaXZhdGUvZ2V0RnJpZW5kbHlVUkwubWpzJztcbmltcG9ydCBwbHVnaW5FdmVudHMgZnJvbSAnLi4vbW9kZWxzL3BsdWdpbkV2ZW50cy5tanMnO1xuaW1wb3J0IHBsdWdpblV0aWxzIGZyb20gJy4uL3V0aWxzL3BsdWdpblV0aWxzLm1qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgdGhlIGZldGNoIEFQSS5cbiAqXG4gKiBXaWxsIGNhbGwgcmVxdWVzdFdpbGxGZXRjaCBvbiBhdmFpbGFibGUgcGx1Z2lucy5cbiAqXG4gKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gZmV0Y2hPcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtwbHVnaW5zXVxuICogQHJldHVybiB7UHJvbWlzZTxSZXNwb25zZT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1jb3JlXG4gKi9cbmNvbnN0IHdyYXBwZWRGZXRjaCA9IGFzeW5jIChyZXF1ZXN0LCBmZXRjaE9wdGlvbnMsIHBsdWdpbnMgPSBbXSkgPT4ge1xuICBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpO1xuICB9XG5cbiAgLy8gVE9ETyBNb3ZlIHRvIGFzc2VydGlvblxuICAvLyBhc3NlcnQuaXNJbnN0YW5jZSh7cmVxdWVzdH0sIFJlcXVlc3QpO1xuXG4gIGNvbnN0IGZhaWxlZEZldGNoUGx1Z2lucyA9IHBsdWdpblV0aWxzLmZpbHRlcihcbiAgICBwbHVnaW5zLCBwbHVnaW5FdmVudHMuRkVUQ0hfRElEX0ZBSUwpO1xuXG4gIC8vIElmIHRoZXJlIGlzIGEgZmV0Y2hEaWRGYWlsIHBsdWdpbiwgd2UgbmVlZCB0byBzYXZlIGEgY2xvbmUgb2YgdGhlXG4gIC8vIG9yaWdpbmFsIHJlcXVlc3QgYmVmb3JlIGl0J3MgZWl0aGVyIG1vZGlmaWVkIGJ5IGEgcmVxdWVzdFdpbGxGZXRjaFxuICAvLyBwbHVnaW4gb3IgYmVmb3JlIHRoZSBvcmlnaW5hbCByZXF1ZXN0J3MgYm9keSBpcyBjb25zdW1lZCB2aWEgZmV0Y2goKS5cbiAgY29uc3Qgb3JpZ2luYWxSZXF1ZXN0ID0gZmFpbGVkRmV0Y2hQbHVnaW5zLmxlbmd0aCA+IDAgP1xuICAgIHJlcXVlc3QuY2xvbmUoKSA6IG51bGw7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKGxldCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgaWYgKHBsdWdpbkV2ZW50cy5SRVFVRVNUX1dJTExfRkVUQ0ggaW4gcGx1Z2luKSB7XG4gICAgICAgIHJlcXVlc3QgPSBhd2FpdCBwbHVnaW5bcGx1Z2luRXZlbnRzLlJFUVVFU1RfV0lMTF9GRVRDSF0uY2FsbChwbHVnaW4sIHtcbiAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LmNsb25lKCksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdG8gYXNzZXJ0aW9uXG4gICAgICAgIC8vIGlzSW5zdGFuY2Uoe3JlcXVlc3R9LCBSZXF1ZXN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ3BsdWdpbi1lcnJvci1yZXF1ZXN0LXdpbGwtZmV0Y2gnLCB7XG4gICAgICB0aHJvd25FcnJvcjogZXJyLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gVGhlIHJlcXVlc3QgY2FuIGJlIGFsdGVyZWQgYnkgcGx1Z2lucyB3aXRoIGByZXF1ZXN0V2lsbEZldGNoYCBtYWtpbmdcbiAgLy8gdGhlIG9yaWdpbmFsIHJlcXVlc3QgKE1vc3QgbGlrZWx5IGZyb20gYSBgZmV0Y2hgIGV2ZW50KSB0byBiZSBkaWZmZXJlbnRcbiAgLy8gdG8gdGhlIFJlcXVlc3Qgd2UgbWFrZS4gUGFzcyBib3RoIHRvIGBmZXRjaERpZEZhaWxgIHRvIGFpZCBkZWJ1Z2dpbmcuXG4gIGNvbnN0IHBsdWdpbkZpbHRlcmVkUmVxdWVzdCA9IHJlcXVlc3QuY2xvbmUoKTtcblxuICAvLyBUT0RPIExvZyB3aGVuIHRoZSBwbHVnaW4gZmlsdGVyZWQgVVJMIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBpbnB1dCByZXF1ZXN0XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QsIGZldGNoT3B0aW9ucyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgTmV0d29yayByZXF1ZXN0IGZvciBgK1xuICAgICAgYCcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nIHJldHVybmVkIGEgcmVzcG9uc2Ugd2l0aCBgICtcbiAgICAgIGBzdGF0dXMgJyR7cmVzcG9uc2Uuc3RhdHVzfScuYCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihgTmV0d29yayByZXF1ZXN0IGZvciBgK1xuICAgICAgYCcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nIHRocmV3IGFuIGVycm9yLmAsIGVycik7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgcGx1Z2luIG9mIGZhaWxlZEZldGNoUGx1Z2lucykge1xuICAgICAgYXdhaXQgcGx1Z2luW3BsdWdpbkV2ZW50cy5GRVRDSF9ESURfRkFJTF0uY2FsbChwbHVnaW4sIHtcbiAgICAgICAgb3JpZ2luYWxSZXF1ZXN0OiBvcmlnaW5hbFJlcXVlc3QuY2xvbmUoKSxcbiAgICAgICAgcmVxdWVzdDogcGx1Z2luRmlsdGVyZWRSZXF1ZXN0LmNsb25lKCksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5cbmNvbnN0IGV4cG9ydHMgPSB7XG4gIGZldGNoOiB3cmFwcGVkRmV0Y2gsXG59O1xuXG5leHBvcnQge2V4cG9ydHMgYXMgZmV0Y2hXcmFwcGVyfTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCAnLi4vX3ZlcnNpb24ubWpzJztcblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgd3JhcHMgY29tbW9uIEluZGV4ZWREQiBmdW5jdGlvbmFsaXR5IGluIGEgcHJvbWlzZS1iYXNlZCBBUEkuXG4gKiBJdCBleHBvc2VzIGFsbCB0aGUgdW5kZXJseWluZyBwb3dlciBhbmQgZnVuY3Rpb25hbGl0eSBvZiBJbmRleGVkREIsIGJ1dFxuICogd3JhcHMgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBmZWF0dXJlcyBpbiBhIHdheSB0aGF0J3MgbXVjaCBzaW1wbGVyIHRvIHVzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBEQldyYXBwZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb25cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBbY2FsbGJhY2tdXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpEQldyYXBwZXIsIEV2ZW50KX0gW2NhbGxiYWNrcy5vbnVwZ3JhZGVuZWVkZWRdXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpEQldyYXBwZXIsIEV2ZW50KX0gW2NhbGxiYWNrcy5vbnZlcnNpb25jaGFuZ2VdXG4gICAqICAgICBEZWZhdWx0cyB0byBEQldyYXBwZXIucHJvdG90eXBlLl9vbnZlcnNpb25jaGFuZ2Ugd2hlbiBub3Qgc3BlY2lmaWVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSwgdmVyc2lvbiwge1xuICAgIG9udXBncmFkZW5lZWRlZCxcbiAgICBvbnZlcnNpb25jaGFuZ2UgPSB0aGlzLl9vbnZlcnNpb25jaGFuZ2UsXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHRoaXMuX29udXBncmFkZW5lZWRlZCA9IG9udXBncmFkZW5lZWRlZDtcbiAgICB0aGlzLl9vbnZlcnNpb25jaGFuZ2UgPSBvbnZlcnNpb25jaGFuZ2U7XG5cbiAgICAvLyBJZiB0aGlzIGlzIG51bGwsIGl0IG1lYW5zIHRoZSBkYXRhYmFzZSBpc24ndCBvcGVuLlxuICAgIHRoaXMuX2RiID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyBhIGNvbm5lY3RlZCB0byBhbiBJREJEYXRhYmFzZSwgaW52b2tlcyBhbnkgb251cGdyYWRlZG5lZWRlZFxuICAgKiBjYWxsYmFjaywgYW5kIGFkZGVkIGFuIG9udmVyc2lvbmNoYW5nZSBjYWxsYmFjayB0byB0aGUgZGF0YWJhc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge0lEQkRhdGFiYXNlfVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgb3BlbigpIHtcbiAgICBpZiAodGhpcy5fZGIpIHJldHVybjtcblxuICAgIHRoaXMuX2RiID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gVGhpcyBmbGFnIGlzIGZsaXBwZWQgdG8gdHJ1ZSBpZiB0aGUgdGltZW91dCBjYWxsYmFjayBydW5zIHByaW9yXG4gICAgICAvLyB0byB0aGUgcmVxdWVzdCBmYWlsaW5nIG9yIHN1Y2NlZWRpbmcuIE5vdGU6IHdlIHVzZSBhIHRpbWVvdXQgaW5zdGVhZFxuICAgICAgLy8gb2YgYW4gb25ibG9ja2VkIGhhbmRsZXIgc2luY2UgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIG9uYmxvY2tlZCB3aWxsXG4gICAgICAvLyBuZXZlciBuZXZlciBydW4uIEEgdGltZW91dCBiZXR0ZXIgaGFuZGxlcyBhbGwgcG9zc2libGUgc2NlbmFyaW9zOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy9JbmRleGVkREIvaXNzdWVzLzIyM1xuICAgICAgbGV0IG9wZW5SZXF1ZXN0VGltZWRPdXQgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBvcGVuUmVxdWVzdFRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIG9wZW4gcmVxdWVzdCB3YXMgYmxvY2tlZCBhbmQgdGltZWQgb3V0JykpO1xuICAgICAgfSwgdGhpcy5PUEVOX1RJTUVPVVQpO1xuXG4gICAgICBjb25zdCBvcGVuUmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuX25hbWUsIHRoaXMuX3ZlcnNpb24pO1xuICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9IChldnQpID0+IHJlamVjdChvcGVuUmVxdWVzdC5lcnJvcik7XG4gICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGlmIChvcGVuUmVxdWVzdFRpbWVkT3V0KSB7XG4gICAgICAgICAgb3BlblJlcXVlc3QudHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgICAgICBldnQudGFyZ2V0LnJlc3VsdC5jbG9zZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX29udXBncmFkZW5lZWRlZCkge1xuICAgICAgICAgIHRoaXMuX29udXBncmFkZW5lZWRlZChldnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gKGV2dCkgPT4ge1xuICAgICAgICBjb25zdCBkYiA9IGV2dC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAob3BlblJlcXVlc3RUaW1lZE91dCkge1xuICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGIub252ZXJzaW9uY2hhbmdlID0gdGhpcy5fb252ZXJzaW9uY2hhbmdlO1xuICAgICAgICAgIHJlc29sdmUoZGIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYGdldCgpYCBtZXRob2QgZm9yIHRoZSBvYmplY3Qgc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIG9iamVjdCBzdG9yZSB0byBwdXQgdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgVGhlIHZhbHVlcyBwYXNzZWQgdG8gdGhlIGRlbGVnYXRlZCBtZXRob2QuXG4gICAqIEByZXR1cm4geyp9IFRoZSBrZXkgb2YgdGhlIGVudHJ5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgZ2V0KHN0b3JlTmFtZSwgLi4uYXJncykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9jYWxsKCdnZXQnLCBzdG9yZU5hbWUsICdyZWFkb25seScsIC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBhZGQoKWAgbWV0aG9kIGZvciB0aGUgb2JqZWN0IHN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lIFRoZSBuYW1lIG9mIHRoZSBvYmplY3Qgc3RvcmUgdG8gcHV0IHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIFRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBkZWxlZ2F0ZWQgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHsqfSBUaGUga2V5IG9mIHRoZSBlbnRyeS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGFkZChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fY2FsbCgnYWRkJywgc3RvcmVOYW1lLCAncmVhZHdyaXRlJywgLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYHB1dCgpYCBtZXRob2QgZm9yIHRoZSBvYmplY3Qgc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWUgVGhlIG5hbWUgb2YgdGhlIG9iamVjdCBzdG9yZSB0byBwdXQgdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgVGhlIHZhbHVlcyBwYXNzZWQgdG8gdGhlIGRlbGVnYXRlZCBtZXRob2QuXG4gICAqIEByZXR1cm4geyp9IFRoZSBrZXkgb2YgdGhlIGVudHJ5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgcHV0KHN0b3JlTmFtZSwgLi4uYXJncykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9jYWxsKCdwdXQnLCBzdG9yZU5hbWUsICdyZWFkd3JpdGUnLCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgZGVsZXRlKClgIG1ldGhvZCBmb3IgdGhlIG9iamVjdCBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlTmFtZVxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgVGhlIHZhbHVlcyBwYXNzZWQgdG8gdGhlIGRlbGVnYXRlZCBtZXRob2QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBkZWxldGUoc3RvcmVOYW1lLCAuLi5hcmdzKSB7XG4gICAgYXdhaXQgdGhpcy5fY2FsbCgnZGVsZXRlJywgc3RvcmVOYW1lLCAncmVhZHdyaXRlJywgLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYGdldEFsbCgpYCBvciBwb2x5ZmlsbHMgaXQgdmlhIHRoZSBgZmluZCgpYFxuICAgKiBtZXRob2QgaW4gb2xkZXIgYnJvd3NlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWVcbiAgICogQHBhcmFtIHsqfSBxdWVyeVxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBnZXRBbGwoc3RvcmVOYW1lLCBxdWVyeSwgY291bnQpIHtcbiAgICBpZiAoJ2dldEFsbCcgaW4gSURCT2JqZWN0U3RvcmUucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fY2FsbCgnZ2V0QWxsJywgc3RvcmVOYW1lLCAncmVhZG9ubHknLCBxdWVyeSwgY291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRBbGxNYXRjaGluZyhzdG9yZU5hbWUsIHtxdWVyeSwgY291bnR9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3VwcG9ydHMgZmxleGlibGUgbG9va3VwIGluIGFuIG9iamVjdCBzdG9yZSBieSBzcGVjaWZ5aW5nIGFuIGluZGV4LFxuICAgKiBxdWVyeSwgZGlyZWN0aW9uLCBhbmQgY291bnQuIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgKiB3aXRoIHRoZSBzaWduYXR1cmUgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtJREJDdXJzb3JEaXJlY3Rpb259IFtvcHRzLmRpcmVjdGlvbl1cbiAgICogQHBhcmFtIHsqfSBbb3B0cy5xdWVyeV1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmluZGV4XSBUaGUgaW5kZXggdG8gdXNlIChpZiBzcGVjaWZpZWQpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuY291bnRdIFRoZSBtYXggbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVLZXlzXSBXaGVuIHRydWUsIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlXG4gICAqICAgICByZXR1cm5lZCBvYmplY3RzIGlzIGNoYW5nZWQgZnJvbSBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gYW4gYXJyYXkgb2ZcbiAgICogICAgIG9iamVjdHMgaW4gdGhlIGZvcm0ge2tleSwgcHJpbWFyeUtleSwgdmFsdWV9LlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGdldEFsbE1hdGNoaW5nKHN0b3JlTmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sICdyZWFkb25seScsIChzdG9yZXMsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JlID0gc3RvcmVzW3N0b3JlTmFtZV07XG4gICAgICBjb25zdCB0YXJnZXQgPSBvcHRzLmluZGV4ID8gc3RvcmUuaW5kZXgob3B0cy5pbmRleCkgOiBzdG9yZTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgdGFyZ2V0Lm9wZW5DdXJzb3Iob3B0cy5xdWVyeSwgb3B0cy5kaXJlY3Rpb24pLm9uc3VjY2VzcyA9IChldnQpID0+IHtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gZXZ0LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICBjb25zdCB7cHJpbWFyeUtleSwga2V5LCB2YWx1ZX0gPSBjdXJzb3I7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG9wdHMuaW5jbHVkZUtleXMgPyB7cHJpbWFyeUtleSwga2V5LCB2YWx1ZX0gOiB2YWx1ZSk7XG4gICAgICAgICAgaWYgKG9wdHMuY291bnQgJiYgcmVzdWx0cy5sZW5ndGggPj0gb3B0cy5jb3VudCkge1xuICAgICAgICAgICAgZG9uZShyZXN1bHRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUocmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBhIGxpc3Qgb2Ygc3RvcmVzLCBhIHRyYW5zYWN0aW9uIHR5cGUsIGFuZCBhIGNhbGxiYWNrIGFuZFxuICAgKiBwZXJmb3JtcyBhIHRyYW5zYWN0aW9uLiBBIHByb21pc2UgaXMgcmV0dXJuZWQgdGhhdCByZXNvbHZlcyB0byB3aGF0ZXZlclxuICAgKiB2YWx1ZSB0aGUgY2FsbGJhY2sgY2hvb3Nlcy4gVGhlIGNhbGxiYWNrIGhvbGRzIGFsbCB0aGUgdHJhbnNhY3Rpb24gbG9naWNcbiAgICogYW5kIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAqICAgMS4gQW4gb2JqZWN0IG1hcHBpbmcgb2JqZWN0IHN0b3JlIG5hbWVzIHRvIElEQk9iamVjdFN0b3JlIHZhbHVlcy5cbiAgICogICAyLiBBIGBkb25lYCBmdW5jdGlvbiwgdGhhdCdzIHVzZWQgdG8gcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aGVuXG4gICAqICAgICAgd2hlbiB0aGUgdHJhbnNhY3Rpb24gaXMgZG9uZS5cbiAgICogICAzLiBBbiBgYWJvcnRgIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB0byBhYm9ydCB0aGUgdHJhbnNhY3Rpb25cbiAgICogICAgICBhdCBhbnkgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzdG9yZU5hbWVzIEFuIGFycmF5IG9mIG9iamVjdCBzdG9yZSBuYW1lc1xuICAgKiAgICAgaW52b2x2ZWQgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBDYW4gYmUgYHJlYWRvbmx5YCBvciBgcmVhZHdyaXRlYC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsIGZ1bmN0aW9uKCksIGZ1bmN0aW9uKCopKTo/SURCUmVxdWVzdH0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNhY3Rpb24gcmFuIGJ5IHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIHRyYW5zYWN0aW9uKHN0b3JlTmFtZXMsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgYXdhaXQgdGhpcy5vcGVuKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHhuID0gdGhpcy5fZGIudHJhbnNhY3Rpb24oc3RvcmVOYW1lcywgdHlwZSk7XG4gICAgICBjb25zdCBkb25lID0gKHZhbHVlKSA9PiByZXNvbHZlKHZhbHVlKTtcbiAgICAgIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgdHJhbnNhY3Rpb24gd2FzIG1hbnVhbGx5IGFib3J0ZWQnKSk7XG4gICAgICAgIHR4bi5hYm9ydCgpO1xuICAgICAgfTtcbiAgICAgIHR4bi5vbmVycm9yID0gKGV2dCkgPT4gcmVqZWN0KGV2dC50YXJnZXQuZXJyb3IpO1xuICAgICAgdHhuLm9uYWJvcnQgPSAoZXZ0KSA9PiByZWplY3QoZXZ0LnRhcmdldC5lcnJvcik7XG4gICAgICB0eG4ub25jb21wbGV0ZSA9ICgpID0+IHJlc29sdmUoKTtcblxuICAgICAgY29uc3Qgc3RvcmVzID0ge307XG4gICAgICBmb3IgKGNvbnN0IHN0b3JlTmFtZSBvZiBzdG9yZU5hbWVzKSB7XG4gICAgICAgIHN0b3Jlc1tzdG9yZU5hbWVdID0gdHhuLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhzdG9yZXMsIGRvbmUsIGFib3J0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGVnYXRlcyBhc3luYyB0byBhIG5hdGl2ZSBJREJPYmplY3RTdG9yZSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIG1ldGhvZCBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lIFRoZSBvYmplY3Qgc3RvcmUgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgQ2FuIGJlIGByZWFkb25seWAgb3IgYHJlYWR3cml0ZWAuXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBUaGUgbGlzdCBvZiBhcmdzIHRvIHBhc3MgdG8gdGhlIG5hdGl2ZSBtZXRob2QuXG4gICAqIEByZXR1cm4geyp9IFRoZSByZXN1bHQgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2NhbGwobWV0aG9kLCBzdG9yZU5hbWUsIHR5cGUsIC4uLmFyZ3MpIHtcbiAgICBhd2FpdCB0aGlzLm9wZW4oKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IChzdG9yZXMsIGRvbmUpID0+IHtcbiAgICAgIHN0b3Jlc1tzdG9yZU5hbWVdW21ldGhvZF0oLi4uYXJncykub25zdWNjZXNzID0gKGV2dCkgPT4ge1xuICAgICAgICBkb25lKGV2dC50YXJnZXQucmVzdWx0KTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCB0eXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgb252ZXJzaW9uY2hhbmdlIGhhbmRsZXIsIHdoaWNoIGNsb3NlcyB0aGUgZGF0YWJhc2Ugc28gb3RoZXJcbiAgICogY29ubmVjdGlvbnMgY2FuIG9wZW4gd2l0aG91dCBiZWluZyBibG9ja2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbnZlcnNpb25jaGFuZ2UoZXZ0KSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbiBvcGVuZWQgYnkgYERCV3JhcHBlci5vcGVuKClgLiBHZW5lcmFsbHkgdGhpcyBtZXRob2RcbiAgICogZG9lc24ndCBuZWVkIHRvIGJlIGNhbGxlZCBzaW5jZTpcbiAgICogICAxLiBJdCdzIHVzdWFsbHkgYmV0dGVyIHRvIGtlZXAgYSBjb25uZWN0aW9uIG9wZW4gc2luY2Ugb3BlbmluZ1xuICAgKiAgICAgIGEgbmV3IGNvbm5lY3Rpb24gaXMgc29tZXdoYXQgc2xvdy5cbiAgICogICAyLiBDb25uZWN0aW9ucyBhcmUgYXV0b21hdGljYWxseSBjbG9zZWQgd2hlbiB0aGUgcmVmZXJlbmNlIGlzXG4gICAqICAgICAgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqIFRoZSBwcmltYXJ5IHVzZSBjYXNlIGZvciBuZWVkaW5nIHRvIGNsb3NlIGEgY29ubmVjdGlvbiBpcyB3aGVuIGFub3RoZXJcbiAgICogcmVmZXJlbmNlICh0eXBpY2FsbHkgaW4gYW5vdGhlciB0YWIpIG5lZWRzIHRvIHVwZ3JhZGUgaXQgYW5kIHdvdWxkIGJlXG4gICAqIGJsb2NrZWQgYnkgdGhlIGN1cnJlbnQsIG9wZW4gY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLl9kYikgdGhpcy5fZGIuY2xvc2UoKTtcbiAgfVxufVxuXG4vLyBFeHBvc2VkIHRvIGxldCB1c2VycyBtb2RpZnkgdGhlIGRlZmF1bHQgdGltZW91dCBvbiBhIHBlci1pbnN0YW5jZVxuLy8gb3IgZ2xvYmFsIGJhc2lzLlxuREJXcmFwcGVyLnByb3RvdHlwZS5PUEVOX1RJTUVPVVQgPSAyMDAwO1xuXG5leHBvcnQge0RCV3JhcHBlcn07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQge1dvcmtib3hFcnJvcn0gZnJvbSAnLi4vX3ByaXZhdGUvV29ya2JveEVycm9yLm1qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbi8qXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgY29udGV4dCBpcyBhIHNlcnZpY2Ugd29ya2VyLlxuICovXG5jb25zdCBpc1N3RW52ID0gKG1vZHVsZU5hbWUpID0+IHtcbiAgaWYgKCEoJ1NlcnZpY2VXb3JrZXJHbG9iYWxTY29wZScgaW4gc2VsZikpIHtcbiAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdub3QtaW4tc3cnLCB7bW9kdWxlTmFtZX0pO1xuICB9XG59O1xuXG4vKlxuICogVGhpcyBtZXRob2QgdGhyb3dzIGlmIHRoZSBzdXBwbGllZCB2YWx1ZSBpcyBub3QgYW4gYXJyYXkuXG4gKiBUaGUgZGVzdHJ1Y3RlZCB2YWx1ZXMgYXJlIHJlcXVpcmVkIHRvIHByb2R1Y2UgYSBtZWFuaW5nZnVsIGVycm9yIGZvciB1c2Vycy5cbiAqIFRoZSBkZXN0cnVjdGVkIGFuZCByZXN0cnVjdHVyZWQgb2JqZWN0IGlzIHNvIGl0J3MgY2xlYXIgd2hhdCBpc1xuICogbmVlZGVkLlxuICovXG5jb25zdCBpc0FycmF5ID0gKHZhbHVlLCB7bW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lfSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbm90LWFuLWFycmF5Jywge1xuICAgICAgbW9kdWxlTmFtZSxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIGZ1bmNOYW1lLFxuICAgICAgcGFyYW1OYW1lLFxuICAgIH0pO1xuICB9XG59O1xuXG5jb25zdCBoYXNNZXRob2QgPSAob2JqZWN0LCBleHBlY3RlZE1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICB7bW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lfSkgPT4ge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIG9iamVjdFtleHBlY3RlZE1ldGhvZF07XG4gIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWlzc2luZy1hLW1ldGhvZCcsIHtwYXJhbU5hbWUsIGV4cGVjdGVkTWV0aG9kLFxuICAgICAgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZX0pO1xuICB9XG59O1xuXG5jb25zdCBpc1R5cGUgPSAob2JqZWN0LCBleHBlY3RlZFR5cGUsXG4gICAgICAgICAgICAgICAge21vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZX0pID0+IHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2luY29ycmVjdC10eXBlJywge3BhcmFtTmFtZSwgZXhwZWN0ZWRUeXBlLFxuICAgICAgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZX0pO1xuICB9XG59O1xuXG5jb25zdCBpc0luc3RhbmNlID0gKG9iamVjdCwgZXhwZWN0ZWRDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAge21vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZX0pID0+IHtcbiAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbmNvcnJlY3QtY2xhc3MnLCB7cGFyYW1OYW1lLCBleHBlY3RlZENsYXNzLFxuICAgICAgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZX0pO1xuICB9XG59O1xuXG5jb25zdCBpc09uZU9mID0gKHZhbHVlLCB2YWxpZFZhbHVlcywge3BhcmFtTmFtZX0pID0+IHtcbiAgaWYgKCF2YWxpZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCdpbnZhbGlkLXZhbHVlJywge1xuICAgICAgcGFyYW1OYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICB2YWxpZFZhbHVlRGVzY3JpcHRpb246IGBWYWxpZCB2YWx1ZXMgYXJlICR7SlNPTi5zdHJpbmdpZnkodmFsaWRWYWx1ZXMpfS5gLFxuICAgIH0pO1xuICB9XG59O1xuXG5jb25zdCBpc0FycmF5T2ZDbGFzcyA9ICh2YWx1ZSwgZXhwZWN0ZWRDbGFzcyxcbiAge21vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZX0pID0+IHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgV29ya2JveEVycm9yKCdub3QtYXJyYXktb2YtY2xhc3MnLCB7XG4gICAgdmFsdWUsIGV4cGVjdGVkQ2xhc3MsXG4gICAgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lLFxuICB9KTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgZm9yIChsZXQgaXRlbSBvZiB2YWx1ZSkge1xuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBmaW5hbEV4cG9ydHMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gbnVsbCA6IHtcbiAgaGFzTWV0aG9kLFxuICBpc0FycmF5LFxuICBpc0luc3RhbmNlLFxuICBpc09uZU9mLFxuICBpc1N3RW52LFxuICBpc1R5cGUsXG4gIGlzQXJyYXlPZkNsYXNzLFxufTtcblxuZXhwb3J0IHtmaW5hbEV4cG9ydHMgYXMgYXNzZXJ0fTtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCAnLi4vX3ZlcnNpb24ubWpzJztcblxuY29uc3QgZ2V0RnJpZW5kbHlVUkwgPSAodXJsKSA9PiB7XG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbik7XG4gIGlmICh1cmxPYmoub3JpZ2luID09PSBsb2NhdGlvbi5vcmlnaW4pIHtcbiAgICByZXR1cm4gdXJsT2JqLnBhdGhuYW1lO1xuICB9XG4gIHJldHVybiB1cmxPYmouaHJlZjtcbn07XG5cbmV4cG9ydCB7Z2V0RnJpZW5kbHlVUkx9O1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cblxuICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IGRlZmF1bHRFeHBvcnQgZnJvbSAnLi9fZGVmYXVsdC5tanMnO1xuaW1wb3J0IExPR19MRVZFTFMgZnJvbSAnLi9tb2RlbHMvTG9nTGV2ZWxzLm1qcyc7XG5pbXBvcnQgKiBhcyBfcHJpdmF0ZSBmcm9tICcuL19wcml2YXRlLm1qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24ubWpzJztcblxuY29uc3QgZmluYWxFeHBvcnRzID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0RXhwb3J0LCB7XG4gIExPR19MRVZFTFMsXG4gIF9wcml2YXRlLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZpbmFsRXhwb3J0cztcbiJdLCJuYW1lcyI6WyJ3b3JrYm94IiwidiIsImUiLCJleHBvcnRlZFZhbHVlIiwiY29kZSIsImFyZ3MiLCJtc2ciLCJsZW5ndGgiLCJKU09OIiwic3RyaW5naWZ5IiwiV29ya2JveEVycm9yIiwiRXJyb3IiLCJlcnJvckNvZGUiLCJkZXRhaWxzIiwibWVzc2FnZUdlbmVyYXRvciIsIm5hbWUiLCJfY2FjaGVOYW1lRGV0YWlscyIsInNlbGYiLCJyZWdpc3RyYXRpb24iLCJzY29wZSIsIl9jcmVhdGVDYWNoZU5hbWUiLCJjYWNoZU5hbWUiLCJwcmVmaXgiLCJzdWZmaXgiLCJmaWx0ZXIiLCJ2YWx1ZSIsImpvaW4iLCJleHBvcnRzIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJ1c2VyQ2FjaGVOYW1lIiwiZ29vZ2xlQW5hbHl0aWNzIiwicHJlY2FjaGUiLCJydW50aW1lIiwibG9nTGV2ZWwiLCJwcm9jZXNzIiwid2FybiIsInNob3VsZFByaW50IiwibWluTGV2ZWwiLCJncm91cExldmVsIiwiTE9HX0xFVkVMUyIsImVycm9yIiwiX3ByaW50Iiwia2V5TmFtZSIsImxvZ0FyZ3MiLCJsZXZlbENvbG9yIiwiaW5kZXhPZiIsImxvZ1ByZWZpeCIsImdyb3VwRW5kIiwiZGVmYXVsdEV4cG9ydCIsImxldmVsVG9Db2xvciIsIk9iamVjdCIsImNvbG9yIiwidW5wcmVmaXhlZCIsInNldHVwTG9ncyIsIldvcmtib3hDb3JlIiwiZXJyIiwiY2FjaGVOYW1lcyIsImdldEdvb2dsZUFuYWx5dGljc05hbWUiLCJnZXRQcmVjYWNoZU5hbWUiLCJnZXRSdW50aW1lTmFtZSIsInVwZGF0ZURldGFpbHMiLCJuZXdMZXZlbCIsInNpbGVudCIsImRlYnVnIiwibmV3TG9nTGV2ZWwiLCJwbHVnaW5zIiwiY2FsbGJhY2tuYW1lIiwicGx1Z2luIiwicHV0V3JhcHBlciIsInJlcXVlc3QiLCJyZXNwb25zZSIsInJlc3BvbnNlVG9DYWNoZSIsIl9pc1Jlc3BvbnNlU2FmZVRvQ2FjaGUiLCJjYWNoZSIsImNhY2hlcyIsIm9wZW4iLCJ1cGRhdGVQbHVnaW5zIiwicGx1Z2luVXRpbHMiLCJwbHVnaW5FdmVudHMiLCJDQUNIRV9ESURfVVBEQVRFIiwib2xkUmVzcG9uc2UiLCJtYXRjaFdyYXBwZXIiLCJwdXQiLCJjYWxsIiwibWF0Y2hPcHRpb25zIiwiY2FjaGVkUmVzcG9uc2UiLCJtYXRjaCIsIkNBQ0hFRF9SRVNQT05TRV9XSUxMX0JFX1VTRUQiLCJwbHVnaW5zVXNlZCIsIkNBQ0hFX1dJTExfVVBEQVRFIiwib2siLCJmZXRjaE9wdGlvbnMiLCJSZXF1ZXN0IiwiZmFpbGVkRmV0Y2hQbHVnaW5zIiwiRkVUQ0hfRElEX0ZBSUwiLCJvcmlnaW5hbFJlcXVlc3QiLCJjbG9uZSIsIlJFUVVFU1RfV0lMTF9GRVRDSCIsInBsdWdpbkZpbHRlcmVkUmVxdWVzdCIsImZldGNoIiwiREJXcmFwcGVyIiwidmVyc2lvbiIsIm9udXBncmFkZW5lZWRlZCIsIm9udmVyc2lvbmNoYW5nZSIsInRoaXMiLCJfb252ZXJzaW9uY2hhbmdlIiwiX25hbWUiLCJfdmVyc2lvbiIsIl9vbnVwZ3JhZGVuZWVkZWQiLCJfZGIiLCJfdGhpcyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwib3BlblJlcXVlc3RUaW1lZE91dCIsIk9QRU5fVElNRU9VVCIsIm9wZW5SZXF1ZXN0IiwiaW5kZXhlZERCIiwib25lcnJvciIsImV2dCIsInRyYW5zYWN0aW9uIiwiYWJvcnQiLCJ0YXJnZXQiLCJyZXN1bHQiLCJjbG9zZSIsIm9uc3VjY2VzcyIsImRiIiwic3RvcmVOYW1lIiwiX3RoaXMyIiwiX2NhbGwiLCJfdGhpczMiLCJfdGhpczQiLCJfdGhpczUiLCJxdWVyeSIsImNvdW50IiwiSURCT2JqZWN0U3RvcmUiLCJwcm90b3R5cGUiLCJfdGhpczYiLCJnZXRBbGxNYXRjaGluZyIsIm9wdHMiLCJfdGhpczciLCJzdG9yZXMiLCJkb25lIiwic3RvcmUiLCJyZXN1bHRzIiwiaW5kZXgiLCJvcGVuQ3Vyc29yIiwiZGlyZWN0aW9uIiwiY3Vyc29yIiwicHJpbWFyeUtleSIsInB1c2giLCJpbmNsdWRlS2V5cyIsImNvbnRpbnVlIiwic3RvcmVOYW1lcyIsInR5cGUiLCJjYWxsYmFjayIsIl90aGlzOCIsInR4biIsIm9uYWJvcnQiLCJvbmNvbXBsZXRlIiwib2JqZWN0U3RvcmUiLCJtZXRob2QiLCJfdGhpczkiLCJ1cmwiLCJ1cmxPYmoiLCJVUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsInBhdGhuYW1lIiwiaHJlZiIsImFzc2lnbiJdLCJtYXBwaW5ncyI6IndZQUFBLFNBQVNBLFFBQVFDLEVBQUUsOEJBQThCLEVBQUcsTUFBTUMsSUNn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"}